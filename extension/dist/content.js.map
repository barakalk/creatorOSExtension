{"version":3,"file":"content.js","sources":["../src/sanitize.ts","../src/content.ts"],"sourcesContent":["import { MAX_DOM_BYTES } from './config';\nimport { logger } from './utils/logger';\n\nconst UNSAFE_TAGS = ['script', 'style', 'noscript', 'iframe'] as const;\nconst UNSAFE_LINK_RELS = ['preload', 'prefetch'] as const;\n\nexport function serializeSanitizedDom(doc: Document): string {\n  const startTime = performance.now();\n  \n  try {\n    // Clone the document to avoid modifying the original\n    const clonedDoc = doc.cloneNode(true) as Document;\n    \n    // Remove unsafe tags\n    UNSAFE_TAGS.forEach(tagName => {\n      const elements = clonedDoc.getElementsByTagName(tagName);\n      // Convert to array to avoid live collection issues during removal\n      Array.from(elements).forEach(element => element.remove());\n    });\n    \n    // Remove unsafe link elements\n    const links = clonedDoc.getElementsByTagName('link');\n    Array.from(links).forEach(link => {\n      const rel = link.getAttribute('rel');\n      if (rel && UNSAFE_LINK_RELS.includes(rel as any)) {\n        link.remove();\n      }\n    });\n    \n    // Remove all on* attributes and clear form values\n    const allElements = clonedDoc.getElementsByTagName('*');\n    Array.from(allElements).forEach(element => {\n      // Remove event handler attributes\n      Array.from(element.attributes).forEach(attr => {\n        if (attr.name.startsWith('on')) {\n          element.removeAttribute(attr.name);\n        }\n      });\n      \n      // Clear form values\n      if (element instanceof HTMLInputElement) {\n        element.value = '';\n        element.removeAttribute('value');\n      } else if (element instanceof HTMLTextAreaElement) {\n        element.value = '';\n        element.textContent = '';\n      } else if (element instanceof HTMLSelectElement) {\n        element.selectedIndex = -1;\n        Array.from(element.options).forEach(option => {\n          option.selected = false;\n          option.removeAttribute('selected');\n        });\n      }\n      \n      // Convert relative image URLs to absolute\n      if (element instanceof HTMLImageElement && element.src) {\n        try {\n          const absoluteUrl = new URL(element.src, doc.baseURI).href;\n          element.src = absoluteUrl;\n        } catch (e) {\n          logger.warn('Failed to convert image URL to absolute:', element.src, e);\n        }\n      }\n    });\n    \n    // Serialize the cleaned document\n    const serializer = new XMLSerializer();\n    let htmlString = '<!doctype html>\\n' + serializer.serializeToString(clonedDoc.documentElement);\n    \n    // Cap the size and add truncation marker if needed\n    if (htmlString.length > MAX_DOM_BYTES) {\n      htmlString = htmlString.substring(0, MAX_DOM_BYTES - '<!--TRUNCATED-->'.length) + '<!--TRUNCATED-->';\n    }\n    \n    const duration = performance.now() - startTime;\n    logger.log(`DOM serialization completed in ${duration.toFixed(2)}ms, size: ${htmlString.length} bytes`);\n    \n    return htmlString;\n  } catch (error) {\n    logger.error('Error during DOM serialization:', error);\n    throw new Error(`Failed to serialize DOM: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}","import { isWhitelisted } from './whitelist';\nimport { serializeSanitizedDom } from './sanitize';\nimport { sendMessage } from './messages';\nimport { CaptureMetadata } from './types/global';\nimport { logger } from './utils/logger';\n\n// Guard to prevent multiple captures per navigation\nlet captureAttempted = false;\n\n// Reset guard on new navigation\nif (document.readyState === 'loading') {\n  captureAttempted = false;\n}\n\nlogger.log('Content script initialized', {\n  url: window.location.href,\n  readyState: document.readyState,\n  captureAttempted,\n});\n\n// Main capture logic\nasync function attemptCapture(forced = false): Promise<void> {\n  if (captureAttempted && !forced) {\n    logger.log('Capture already attempted for this navigation, skipping');\n    return;\n  }\n  \n  if (!forced) {\n    captureAttempted = true;\n  }\n  \n  try {\n    const url = window.location.href;\n    \n    // Check if URL is whitelisted\n    const whitelisted = await isWhitelisted(url);\n    if (!whitelisted) {\n      logger.log('URL not whitelisted, skipping capture');\n      return;\n    }\n    \n    logger.log('Starting DOM capture for:', url);\n    \n    // Serialize the DOM\n    const domHtml = serializeSanitizedDom(document);\n    \n    // Collect metadata\n    const meta: CaptureMetadata = {\n      title: document.title,\n      userAgent: navigator.userAgent,\n      viewport: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n      },\n      timestamp: Date.now(),\n    };\n    \n    // Send capture message to background\n    const response = await sendMessage({\n      type: 'CAPTURE_DOM',\n      payload: {\n        url,\n        domHtml,\n        meta,\n      },\n    });\n    \n    if (response?.ok) {\n      logger.log('DOM capture successful:', response.captureId);\n    } else {\n      logger.error('DOM capture failed:', response?.error);\n    }\n  } catch (error) {\n    logger.error('Error during capture attempt:', error);\n  }\n}\n\n// Listen for manual capture requests from popup\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  logger.log('Content script received message:', message.type);\n  \n  if (message.type === 'CAPTURE_REQUEST') {\n    attemptCapture(true) // Force capture regardless of guard\n      .then(() => sendResponse({ success: true }))\n      .catch((error) => {\n        logger.error('Manual capture failed:', error);\n        sendResponse({ success: false, error: error.message });\n      });\n    return true; // Keep message channel open for async response\n  }\n});\n\n// Auto-capture on document idle (if not already attempted)\nif (document.readyState === 'complete') {\n  // Document already loaded, attempt capture immediately\n  attemptCapture();\n} else {\n  // Wait for document to be ready\n  if (document.readyState === 'interactive') {\n    // DOM ready but resources may still be loading\n    attemptCapture();\n  } else {\n    // Document still loading, wait for DOMContentLoaded\n    document.addEventListener('DOMContentLoaded', () => {\n      attemptCapture();\n    });\n  }\n}"],"names":[],"mappings":"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"}