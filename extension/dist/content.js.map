{
  "version": 3,
  "sources": ["../src/config.ts", "../src/utils/logger.ts", "../src/whitelist.ts", "../src/sanitize.ts", "../src/messages.ts", "../src/content.ts"],
  "sourcesContent": ["export const API_BASE = 'http://localhost:3000'; // changeable\n// export const WHITELIST_ENDPOINT = `${API_BASE}/api/whitelist`;\nexport const MAX_DOM_BYTES = 1_500_000; // ~1.5MB\nexport const DEBUG = true;\n\n// Demo mode: when true, API calls are mocked so you can test without a backend\nexport const DEMO_MODE = true;\n\n// Cache duration for whitelist in milliseconds (10 minutes)\nexport const WHITELIST_CACHE_DURATION = 10 * 60 * 1000;\n\n// Request timeout in milliseconds\nexport const REQUEST_TIMEOUT = 30000; // 30 seconds\n\n// Storage keys\nexport const STORAGE_KEYS = {\n  WHITELIST_CACHE: 'whitelist_cache',\n  WHITELIST_CACHE_TIMESTAMP: 'whitelist_cache_timestamp',\n  CAPTURE_TOGGLE_PREFIX: 'host:', // followed by hostname:captureEnabled\n} as const;", "import { DEBUG } from '../config';\n\nconst LOG_PREFIX = '[Creator OS Capture]';\n\nexport const logger = {\n  log(...args: any[]): void {\n    if (DEBUG) {\n      console.log(LOG_PREFIX, ...args);\n    }\n  },\n\n  warn(...args: any[]): void {\n    if (DEBUG) {\n      console.warn(LOG_PREFIX, ...args);\n    }\n  },\n\n  error(...args: any[]): void {\n    if (DEBUG) {\n      console.error(LOG_PREFIX, ...args);\n    }\n  },\n\n  info(...args: any[]): void {\n    if (DEBUG) {\n      console.info(LOG_PREFIX, ...args);\n    }\n  },\n\n  debug(...args: any[]): void {\n    if (DEBUG) {\n      console.debug(LOG_PREFIX, ...args);\n    }\n  },\n};", "import { STORAGE_KEYS } from './config';\nimport { WhitelistPattern } from './types/global';\nimport { logger } from './utils/logger';\n\nexport async function isWhitelisted(url: string): Promise<boolean> {\n  try {\n    const patterns = await getWhitelistPatterns();\n    const hostname = new URL(url).hostname;\n    \n    // Check if patterns match the URL\n    const isPatternMatch = patterns.some(pattern => matchesPattern(url, pattern.pattern));\n    \n    if (!isPatternMatch) {\n      logger.log(`URL not in whitelist patterns: ${url}`);\n      return false;\n    }\n    \n    // Check per-hostname toggle\n    const captureEnabled = await getHostCaptureToggle(hostname);\n    \n    logger.log(`Whitelist check for ${url}: pattern match=${isPatternMatch}, host toggle=${captureEnabled}`);\n    return captureEnabled;\n  } catch (error) {\n    logger.error('Error checking whitelist:', error);\n    return false;\n  }\n}\n\nasync function getWhitelistPatterns(): Promise<WhitelistPattern[]> {\n  // Hardcoded whitelist patterns\n  const patterns: WhitelistPattern[] = [\n    { pattern: 'https://www.midjourney.com/imagine*' },\n    { pattern: 'https://*.midjourney.com/*' },\n  ];\n  logger.log('Using hardcoded whitelist patterns');\n  return patterns;\n}\n\nfunction matchesPattern(url: string, pattern: string): boolean {\n  try {\n    // Convert wildcard pattern to regex\n    // Escape special regex characters except *\n    const escapedPattern = pattern.replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    // Replace * with .*\n    const regexPattern = escapedPattern.replace(/\\\\\\*/g, '.*');\n    // Anchor the pattern\n    const regex = new RegExp(`^${regexPattern}$`, 'i');\n    \n    return regex.test(url);\n  } catch (error) {\n    logger.error('Error matching pattern:', pattern, error);\n    return false;\n  }\n}\n\n// Remove caching functions as they are no longer needed with hardcoded whitelist\n// async function getCachedWhitelist(): Promise<WhitelistCache | null> {\n//   try {\n//     const result = await chrome.storage.session.get([\n//       STORAGE_KEYS.WHITELIST_CACHE,\n//       STORAGE_KEYS.WHITELIST_CACHE_TIMESTAMP,\n//     ]);\n// \n//     const patterns = result[STORAGE_KEYS.WHITELIST_CACHE];\n//     const timestamp = result[STORAGE_KEYS.WHITELIST_CACHE_TIMESTAMP];\n// \n//     if (patterns && timestamp) {\n//       return { patterns, timestamp };\n//     }\n// \n//     return null;\n//   } catch (error) {\n//     logger.error('Error reading cached whitelist:', error);\n//     return null;\n//   }\n// }\n// \n// async function cacheWhitelist(patterns: WhitelistPattern[]): Promise<void> {\n//   try {\n//     await chrome.storage.session.set({\n//       [STORAGE_KEYS.WHITELIST_CACHE]: patterns,\n//       [STORAGE_KEYS.WHITELIST_CACHE_TIMESTAMP]: Date.now(),\n//     });\n// \n//     logger.log('Whitelist patterns cached successfully');\n//   } catch (error) {\n//     logger.error('Error caching whitelist patterns:', error);\n//   }\n// }\n// \n// function isCacheValid(timestamp: number): boolean {\n//   return Date.now() - timestamp < WHITELIST_CACHE_DURATION;\n// }\n\nexport async function getHostCaptureToggle(hostname: string): Promise<boolean> {\n  try {\n    const key = `${STORAGE_KEYS.CAPTURE_TOGGLE_PREFIX}${hostname}:captureEnabled`;\n    const result = await chrome.storage.sync.get(key);\n    \n    // Default to true if not set\n    return result[key] !== false;\n  } catch (error) {\n    logger.error('Error getting host capture toggle:', error);\n    return true; // Default to enabled\n  }\n}\n\nexport async function setHostCaptureToggle(hostname: string, enabled: boolean): Promise<void> {\n  try {\n    const key = `${STORAGE_KEYS.CAPTURE_TOGGLE_PREFIX}${hostname}:captureEnabled`;\n    await chrome.storage.sync.set({ [key]: enabled });\n    \n    logger.log(`Set capture toggle for ${hostname}: ${enabled}`);\n  } catch (error) {\n    logger.error('Error setting host capture toggle:', error);\n    throw error;\n  }\n}", "import { MAX_DOM_BYTES } from './config';\nimport { logger } from './utils/logger';\n\nconst UNSAFE_TAGS = ['script', 'style', 'noscript', 'iframe'] as const;\nconst UNSAFE_LINK_RELS = ['preload', 'prefetch'] as const;\n\nexport function serializeSanitizedDom(doc: Document): string {\n  const startTime = performance.now();\n  \n  try {\n    // Clone the document to avoid modifying the original\n    const clonedDoc = doc.cloneNode(true) as Document;\n    \n    // Remove unsafe tags\n    UNSAFE_TAGS.forEach(tagName => {\n      const elements = clonedDoc.getElementsByTagName(tagName);\n      // Convert to array to avoid live collection issues during removal\n      Array.from(elements).forEach(element => element.remove());\n    });\n    \n    // Remove unsafe link elements\n    const links = clonedDoc.getElementsByTagName('link');\n    Array.from(links).forEach(link => {\n      const rel = link.getAttribute('rel');\n      if (rel && UNSAFE_LINK_RELS.includes(rel as any)) {\n        link.remove();\n      }\n    });\n    \n    // Remove all on* attributes and clear form values\n    const allElements = clonedDoc.getElementsByTagName('*');\n    Array.from(allElements).forEach(element => {\n      // Remove event handler attributes\n      Array.from(element.attributes).forEach(attr => {\n        if (attr.name.startsWith('on')) {\n          element.removeAttribute(attr.name);\n        }\n      });\n      \n      // Clear form values\n      if (element instanceof HTMLInputElement) {\n        element.value = '';\n        element.removeAttribute('value');\n      } else if (element instanceof HTMLTextAreaElement) {\n        element.value = '';\n        element.textContent = '';\n      } else if (element instanceof HTMLSelectElement) {\n        element.selectedIndex = -1;\n        Array.from(element.options).forEach(option => {\n          option.selected = false;\n          option.removeAttribute('selected');\n        });\n      }\n      \n      // Convert relative image URLs to absolute\n      if (element instanceof HTMLImageElement && element.src) {\n        try {\n          const absoluteUrl = new URL(element.src, doc.baseURI).href;\n          element.src = absoluteUrl;\n        } catch (e) {\n          logger.warn('Failed to convert image URL to absolute:', element.src, e);\n        }\n      }\n    });\n    \n    // Serialize the cleaned document\n    const serializer = new XMLSerializer();\n    let htmlString = '<!doctype html>\\n' + serializer.serializeToString(clonedDoc.documentElement);\n    \n    // Cap the size and add truncation marker if needed\n    if (htmlString.length > MAX_DOM_BYTES) {\n      htmlString = htmlString.substring(0, MAX_DOM_BYTES - '<!--TRUNCATED-->'.length) + '<!--TRUNCATED-->';\n    }\n    \n    const duration = performance.now() - startTime;\n    logger.log(`DOM serialization completed in ${duration.toFixed(2)}ms, size: ${htmlString.length} bytes`);\n    \n    return htmlString;\n  } catch (error) {\n    logger.error('Error during DOM serialization:', error);\n    throw new Error(`Failed to serialize DOM: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}", "import { CaptureDomPayload } from './types/global';\n\nexport type Msg =\n  | { type: 'CAPTURE_REQUEST'; url: string }\n  | { type: 'CAPTURE_DOM'; payload: CaptureDomPayload }\n  | { type: 'CAPTURE_RESULT'; ok: boolean; captureId?: string; error?: string }\n  | { type: 'TOGGLE_CAPTURE'; hostname: string; enabled: boolean }\n  | { type: 'GET_TOGGLE'; hostname: string }\n  | { type: 'GET_TOGGLE_RESPONSE'; hostname: string; enabled: boolean }\n  | { type: 'LIST_CAPTURES' }\n  | { type: 'GET_CAPTURE_HTML'; id: string }\n  | { type: 'DELETE_CAPTURE'; id: string };\n\n// Helper functions for message handling\nexport function sendMessage<T extends Msg>(message: T): Promise<any> {\n  return new Promise((resolve, reject) => {\n    chrome.runtime.sendMessage(message, (response) => {\n      if (chrome.runtime.lastError) {\n        reject(new Error(chrome.runtime.lastError.message));\n      } else {\n        resolve(response);\n      }\n    });\n  });\n}\n\nexport function sendMessageToTab<T extends Msg>(tabId: number, message: T): Promise<any> {\n  return new Promise((resolve, reject) => {\n    chrome.tabs.sendMessage(tabId, message, (response) => {\n      if (chrome.runtime.lastError) {\n        reject(new Error(chrome.runtime.lastError.message));\n      } else {\n        resolve(response);\n      }\n    });\n  });\n}", "import { isWhitelisted } from './whitelist';\nimport { serializeSanitizedDom } from './sanitize';\nimport { sendMessage } from './messages';\nimport { CaptureMetadata } from './types/global';\nimport { logger } from './utils/logger';\n\n// Guard to prevent multiple captures per navigation\nlet captureAttempted = false;\n\n// Reset guard on new navigation\nif (document.readyState === 'loading') {\n  captureAttempted = false;\n}\n\nlogger.log('Content script initialized', {\n  url: window.location.href,\n  readyState: document.readyState,\n  captureAttempted,\n});\n\n// Main capture logic\nasync function attemptCapture(forced = false): Promise<void> {\n  if (captureAttempted && !forced) {\n    logger.log('Capture already attempted for this navigation, skipping');\n    return;\n  }\n  \n  if (!forced) {\n    captureAttempted = true;\n  }\n  \n  try {\n    const url = window.location.href;\n    \n    // Check if URL is whitelisted\n    const whitelisted = await isWhitelisted(url);\n    if (!whitelisted) {\n      logger.log('URL not whitelisted, skipping capture');\n      return;\n    }\n    \n    logger.log('Starting DOM capture for:', url);\n    \n    // Serialize the DOM\n    const domHtml = serializeSanitizedDom(document);\n    \n    // Collect metadata\n    const meta: CaptureMetadata = {\n      title: document.title,\n      userAgent: navigator.userAgent,\n      viewport: {\n        width: window.innerWidth,\n        height: window.innerHeight,\n      },\n      timestamp: Date.now(),\n    };\n    \n    // Send capture message to background\n    const response = await sendMessage({\n      type: 'CAPTURE_DOM',\n      payload: {\n        url,\n        domHtml,\n        meta,\n      },\n    });\n    \n    if (response?.ok) {\n      logger.log('DOM capture successful:', response.captureId);\n    } else {\n      logger.error('DOM capture failed:', response?.error);\n    }\n  } catch (error) {\n    logger.error('Error during capture attempt:', error);\n  }\n}\n\n// Listen for manual capture requests from popup\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  logger.log('Content script received message:', message.type);\n  \n  if (message.type === 'CAPTURE_REQUEST') {\n    attemptCapture(true) // Force capture regardless of guard\n      .then(() => sendResponse({ success: true }))\n      .catch((error) => {\n        logger.error('Manual capture failed:', error);\n        sendResponse({ success: false, error: error.message });\n      });\n    return true; // Keep message channel open for async response\n  }\n});\n\n// Auto-capture on document idle (if not already attempted)\nif (document.readyState === 'complete') {\n  // Document already loaded, attempt capture immediately\n  attemptCapture();\n} else {\n  // Wait for document to be ready\n  if (document.readyState === 'interactive') {\n    // DOM ready but resources may still be loading\n    attemptCapture();\n  } else {\n    // Document still loading, wait for DOMContentLoaded\n    document.addEventListener('DOMContentLoaded', () => {\n      attemptCapture();\n    });\n  }\n}"],
  "mappings": "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",
  "names": []
}
