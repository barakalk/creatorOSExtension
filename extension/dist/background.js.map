{"version":3,"file":"background.js","sources":["../src/api.ts","../src/background.ts"],"sourcesContent":["import { API_BASE, REQUEST_TIMEOUT, DEMO_MODE } from './config';\nimport { CaptureDomPayload, CaptureResponse } from './types/global';\nimport { logger } from './utils/logger';\n\nfunction simpleHash(input: string): string {\n  let hash = 0;\n  for (let i = 0; i < input.length; i++) {\n    hash = (hash << 5) - hash + input.charCodeAt(i);\n    hash |= 0;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nexport async function postCaptureDom(payload: CaptureDomPayload): Promise<CaptureResponse> {\n  if (DEMO_MODE) {\n    const mock: CaptureResponse = {\n      id: `demo-${Date.now()}`,\n      domHash: simpleHash(`${payload.url}|${payload.domHtml.length}`),\n    } as any;\n    logger.log('[DEMO] Pretending to post DOM capture:', { url: payload.url, size: payload.domHtml.length });\n    return Promise.resolve(mock);\n  }\n\n  const url = `${API_BASE}/api/capture/dom`;\n  \n  logger.log('Posting DOM capture:', {\n    url: payload.url,\n    domSize: payload.domHtml.length,\n    meta: payload.meta,\n  });\n  \n  try {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);\n    \n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(payload),\n      signal: controller.signal,\n    });\n    \n    clearTimeout(timeoutId);\n    \n    if (!response.ok) {\n      const errorText = await response.text().catch(() => 'Unknown error');\n      throw new Error(`HTTP ${response.status}: ${errorText}`);\n    }\n    \n    const result: CaptureResponse = await response.json();\n    \n    if (!result.id || !result.domHash) {\n      throw new Error('Invalid response: missing id or domHash');\n    }\n    \n    logger.log('DOM capture successful:', result);\n    return result;\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      throw new Error('Request timed out');\n    }\n    \n    logger.error('Failed to post DOM capture:', error);\n    throw error;\n  }\n}\n\nexport async function triggerParse(captureId: string): Promise<void> {\n  if (DEMO_MODE) {\n    logger.log('[DEMO] Pretending to trigger parse for capture:', captureId);\n    return Promise.resolve();\n  }\n\n  const url = `${API_BASE}/api/parse/${captureId}`;\n  \n  logger.log('Triggering parse for capture:', captureId);\n  \n  try {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);\n    \n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      signal: controller.signal,\n    });\n    \n    clearTimeout(timeoutId);\n    \n    if (!response.ok) {\n      const errorText = await response.text().catch(() => 'Unknown error');\n      throw new Error(`HTTP ${response.status}: ${errorText}`);\n    }\n    \n    logger.log('Parse trigger successful for capture:', captureId);\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      throw new Error('Request timed out');\n    }\n    \n    logger.error('Failed to trigger parse:', error);\n    throw error;\n  }\n}","import { Msg } from './messages';\nimport { postCaptureDom, triggerParse } from './api';\nimport { getHostCaptureToggle, setHostCaptureToggle } from './whitelist';\nimport { logger } from './utils/logger';\nimport { CaptureMetadata } from './types/global';\n\nlogger.log('Background service worker initialized');\n\nchrome.runtime.onMessage.addListener((message: Msg, _sender, sendResponse) => {\n  logger.log('Background received message:', message.type);\n  \n  switch (message.type) {\n    case 'CAPTURE_DOM':\n      handleCaptureDom(message.payload, sendResponse);\n      return true; // Keep message channel open for async response\n      \n    case 'GET_TOGGLE':\n      handleGetToggle(message.hostname, sendResponse);\n      return true;\n      \n    case 'TOGGLE_CAPTURE':\n      handleToggleCapture(message.hostname, message.enabled, sendResponse);\n      return true;\n      \n    default:\n      logger.warn('Unknown message type:', (message as any).type);\n      sendResponse({ error: 'Unknown message type' });\n  }\n});\n\nasync function handleCaptureDom(\n  payload: { url: string; domHtml: string; meta?: CaptureMetadata },\n  sendResponse: (response?: any) => void\n) {\n  try {\n    logger.log('Processing DOM capture request:', {\n      url: payload.url,\n      domSize: payload.domHtml.length,\n    });\n\n    // Save DOM dump to a file for inspection\n    try {\n      const blob = new Blob([payload.domHtml], { type: 'text/html' });\n      const url = URL.createObjectURL(blob);\n      await chrome.downloads.download({\n        url,\n        filename: 'creator-os-dom-dump.html',\n        saveAs: true,\n      });\n      logger.log('DOM dump download initiated');\n    } catch (e) {\n      logger.warn('Could not download DOM dump:', e);\n    }\n    \n    // Step 1: Post DOM to backend (or demo mock)\n    const captureResult = await postCaptureDom(payload);\n    \n    // Step 2: Trigger parse immediately\n    await triggerParse(captureResult.id);\n    \n    // Send success response\n    sendResponse({\n      type: 'CAPTURE_RESULT',\n      ok: true,\n      captureId: captureResult.id,\n    });\n    \n    logger.log('Capture and parse completed successfully:', captureResult.id);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    \n    logger.error('Capture processing failed:', error);\n    \n    sendResponse({\n      type: 'CAPTURE_RESULT',\n      ok: false,\n      error: errorMessage,\n    });\n  }\n}\n\nasync function handleGetToggle(hostname: string, sendResponse: (response?: any) => void) {\n  try {\n    const enabled = await getHostCaptureToggle(hostname);\n    sendResponse({\n      type: 'GET_TOGGLE_RESPONSE',\n      hostname,\n      enabled,\n    });\n  } catch (error) {\n    logger.error('Failed to get toggle state:', error);\n    sendResponse({\n      type: 'GET_TOGGLE_RESPONSE',\n      hostname,\n      enabled: true, // Default to enabled\n    });\n  }\n}\n\nasync function handleToggleCapture(\n  hostname: string,\n  enabled: boolean,\n  sendResponse: (response?: any) => void\n) {\n  try {\n    await setHostCaptureToggle(hostname, enabled);\n    sendResponse({ success: true });\n    \n    logger.log(`Capture toggle updated for ${hostname}: ${enabled}`);\n  } catch (error) {\n    logger.error('Failed to set toggle state:', error);\n    sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });\n  }\n}"],"names":[],"mappings":"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"}