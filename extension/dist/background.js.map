{"version":3,"file":"background.js","sources":["../src/api.ts","../src/utils/storage.ts","../src/background.ts"],"sourcesContent":["import { API_BASE, REQUEST_TIMEOUT, DEMO_MODE } from './config';\nimport { CaptureDomPayload, CaptureResponse } from './types/global';\nimport { logger } from './utils/logger';\n\nfunction simpleHash(input: string): string {\n  let hash = 0;\n  for (let i = 0; i < input.length; i++) {\n    hash = (hash << 5) - hash + input.charCodeAt(i);\n    hash |= 0;\n  }\n  return Math.abs(hash).toString(16);\n}\n\nexport async function postCaptureDom(payload: CaptureDomPayload): Promise<CaptureResponse> {\n  if (DEMO_MODE) {\n    const mock: CaptureResponse = {\n      id: `demo-${Date.now()}`,\n      domHash: simpleHash(`${payload.url}|${payload.domHtml.length}`),\n    } as any;\n    logger.log('[DEMO] Pretending to post DOM capture:', { url: payload.url, size: payload.domHtml.length });\n    return Promise.resolve(mock);\n  }\n\n  const url = `${API_BASE}/api/capture/dom`;\n  \n  logger.log('Posting DOM capture:', {\n    url: payload.url,\n    domSize: payload.domHtml.length,\n    meta: payload.meta,\n  });\n  \n  try {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);\n    \n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(payload),\n      signal: controller.signal,\n    });\n    \n    clearTimeout(timeoutId);\n    \n    if (!response.ok) {\n      const errorText = await response.text().catch(() => 'Unknown error');\n      throw new Error(`HTTP ${response.status}: ${errorText}`);\n    }\n    \n    const result: CaptureResponse = await response.json();\n    \n    if (!result.id || !result.domHash) {\n      throw new Error('Invalid response: missing id or domHash');\n    }\n    \n    logger.log('DOM capture successful:', result);\n    return result;\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      throw new Error('Request timed out');\n    }\n    \n    logger.error('Failed to post DOM capture:', error);\n    throw error;\n  }\n}\n\nexport async function triggerParse(captureId: string): Promise<void> {\n  if (DEMO_MODE) {\n    logger.log('[DEMO] Pretending to trigger parse for capture:', captureId);\n    return Promise.resolve();\n  }\n\n  const url = `${API_BASE}/api/parse/${captureId}`;\n  \n  logger.log('Triggering parse for capture:', captureId);\n  \n  try {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT);\n    \n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      signal: controller.signal,\n    });\n    \n    clearTimeout(timeoutId);\n    \n    if (!response.ok) {\n      const errorText = await response.text().catch(() => 'Unknown error');\n      throw new Error(`HTTP ${response.status}: ${errorText}`);\n    }\n    \n    logger.log('Parse trigger successful for capture:', captureId);\n  } catch (error) {\n    if (error instanceof Error && error.name === 'AbortError') {\n      throw new Error('Request timed out');\n    }\n    \n    logger.error('Failed to trigger parse:', error);\n    throw error;\n  }\n}","export interface DomCaptureRecord {\n  id: string;\n  domHtml: string;\n}\n\nexport interface DomCaptureMetaRecord {\n  id: string;\n  url: string;\n  timestamp: number;\n  sizeBytes: number;\n  title?: string;\n}\n\nconst DB_NAME = 'creator_os_captures';\nconst DB_VERSION = 1;\nconst STORE_DATA = 'captures';\nconst STORE_META = 'metadata';\n\nfunction openDb(): Promise<IDBDatabase> {\n  return new Promise((resolve, reject) => {\n    const req = indexedDB.open(DB_NAME, DB_VERSION);\n    req.onupgradeneeded = () => {\n      const db = req.result;\n      if (!db.objectStoreNames.contains(STORE_DATA)) {\n        db.createObjectStore(STORE_DATA, { keyPath: 'id' });\n      }\n      if (!db.objectStoreNames.contains(STORE_META)) {\n        const meta = db.createObjectStore(STORE_META, { keyPath: 'id' });\n        meta.createIndex('timestamp', 'timestamp');\n        meta.createIndex('url', 'url');\n      }\n    };\n    req.onsuccess = () => resolve(req.result);\n    req.onerror = () => reject(req.error);\n  });\n}\n\nexport async function saveCaptureToDb(id: string, domHtml: string, meta: DomCaptureMetaRecord): Promise<void> {\n  const db = await openDb();\n  await new Promise<void>((resolve, reject) => {\n    const tx = db.transaction([STORE_DATA, STORE_META], 'readwrite');\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n    (tx.objectStore(STORE_DATA) as IDBObjectStore).put({ id, domHtml } as DomCaptureRecord);\n    (tx.objectStore(STORE_META) as IDBObjectStore).put(meta);\n  });\n}\n\nexport async function listCaptures(limit = 100): Promise<DomCaptureMetaRecord[]> {\n  const db = await openDb();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_META, 'readonly');\n    const store = tx.objectStore(STORE_META);\n    const index = store.index('timestamp');\n    const results: DomCaptureMetaRecord[] = [];\n    const cursorReq = index.openCursor(undefined, 'prev');\n    cursorReq.onsuccess = () => {\n      const cursor = cursorReq.result;\n      if (cursor && results.length < limit) {\n        results.push(cursor.value as DomCaptureMetaRecord);\n        cursor.continue();\n      } else {\n        resolve(results);\n      }\n    };\n    cursorReq.onerror = () => reject(cursorReq.error);\n  });\n}\n\nexport async function getCaptureHtml(id: string): Promise<string | null> {\n  const db = await openDb();\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(STORE_DATA, 'readonly');\n    const store = tx.objectStore(STORE_DATA);\n    const req = store.get(id);\n    req.onsuccess = () => resolve(req.result ? (req.result as DomCaptureRecord).domHtml : null);\n    req.onerror = () => reject(req.error);\n  });\n}\n\nexport async function deleteCapture(id: string): Promise<void> {\n  const db = await openDb();\n  await new Promise<void>((resolve, reject) => {\n    const tx = db.transaction([STORE_DATA, STORE_META], 'readwrite');\n    tx.oncomplete = () => resolve();\n    tx.onerror = () => reject(tx.error);\n    tx.objectStore(STORE_DATA).delete(id);\n    tx.objectStore(STORE_META).delete(id);\n  });\n}\n","import { Msg } from './messages';\nimport { postCaptureDom, triggerParse } from './api';\nimport { getHostCaptureToggle, setHostCaptureToggle } from './whitelist';\nimport { logger } from './utils/logger';\nimport { saveCaptureToDb, listCaptures, getCaptureHtml, deleteCapture } from './utils/storage';\nimport { CaptureMetadata } from './types/global';\n\nlogger.log('Background service worker initialized');\n\nchrome.runtime.onMessage.addListener((message: Msg, _sender, sendResponse) => {\n  logger.log('Background received message:', (message as any).type);\n  \n  switch (message.type) {\n    case 'CAPTURE_DOM':\n      handleCaptureDom(message.payload, sendResponse);\n      return true;\n    case 'GET_TOGGLE':\n      handleGetToggle(message.hostname, sendResponse);\n      return true;\n    case 'TOGGLE_CAPTURE':\n      handleToggleCapture(message.hostname, message.enabled, sendResponse);\n      return true;\n    case 'LIST_CAPTURES':\n      listCaptures().then((items) => sendResponse({ ok: true, items })).catch((e) => sendResponse({ ok: false, error: String(e) }));\n      return true;\n    case 'GET_CAPTURE_HTML':\n      getCaptureHtml(message.id).then((html) => sendResponse({ ok: true, html })).catch((e) => sendResponse({ ok: false, error: String(e) }));\n      return true;\n    case 'DELETE_CAPTURE':\n      deleteCapture(message.id).then(() => sendResponse({ ok: true })).catch((e) => sendResponse({ ok: false, error: String(e) }));\n      return true;\n    default:\n      logger.warn('Unknown message type:', (message as any).type);\n      sendResponse({ error: 'Unknown message type' });\n  }\n});\n\nasync function handleCaptureDom(\n  payload: { url: string; domHtml: string; meta?: CaptureMetadata },\n  sendResponse: (response?: any) => void\n) {\n  try {\n    logger.log('Processing DOM capture request:', {\n      url: payload.url,\n      domSize: payload.domHtml.length,\n    });\n\n    // Persist to IndexedDB with metadata (hybrid approach retains download fallback below)\n    const captureId = `cap_${Date.now()}`;\n    await saveCaptureToDb(captureId, payload.domHtml, {\n      id: captureId,\n      url: payload.url,\n      timestamp: payload.meta?.timestamp ?? Date.now(),\n      title: payload.meta?.title,\n      sizeBytes: payload.domHtml.length,\n    });\n\n    // Optional: also initiate a download (kept as backup UX)\n    try {\n      const blob = new Blob([payload.domHtml], { type: 'text/html' });\n      const url = URL.createObjectURL(blob);\n      await chrome.downloads.download({ url, filename: `creator-os/${captureId}.html` });\n    } catch (e) {\n      logger.warn('Download backup failed or was blocked:', e);\n    }\n\n    // Post to backend / demo flow\n    const captureResult = await postCaptureDom(payload);\n    await triggerParse(captureResult.id);\n\n    sendResponse({ type: 'CAPTURE_RESULT', ok: true, captureId: captureResult.id, storedId: captureId });\n    logger.log('Capture stored and processed:', { storedId: captureId, captureId: captureResult.id });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    logger.error('Capture processing failed:', error);\n    sendResponse({ type: 'CAPTURE_RESULT', ok: false, error: errorMessage });\n  }\n}\n\nasync function handleGetToggle(hostname: string, sendResponse: (response?: any) => void) {\n  try {\n    const enabled = await getHostCaptureToggle(hostname);\n    sendResponse({ type: 'GET_TOGGLE_RESPONSE', hostname, enabled });\n  } catch (error) {\n    logger.error('Failed to get toggle state:', error);\n    sendResponse({ type: 'GET_TOGGLE_RESPONSE', hostname, enabled: true });\n  }\n}\n\nasync function handleToggleCapture(\n  hostname: string,\n  enabled: boolean,\n  sendResponse: (response?: any) => void\n) {\n  try {\n    await setHostCaptureToggle(hostname, enabled);\n    sendResponse({ success: true });\n    logger.log(`Capture toggle updated for ${hostname}: ${enabled}`);\n  } catch (error) {\n    logger.error('Failed to set toggle state:', error);\n    sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });\n  }\n}"],"names":[],"mappings":"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"}