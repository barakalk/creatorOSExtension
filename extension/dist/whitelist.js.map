{"version":3,"file":"whitelist.js","sources":["../src/config.ts","../src/whitelist.ts"],"sourcesContent":["export const API_BASE = 'http://localhost:3000'; // changeable\n// export const WHITELIST_ENDPOINT = `${API_BASE}/api/whitelist`;\nexport const MAX_DOM_BYTES = 1_500_000; // ~1.5MB\nexport const DEBUG = true;\n\n// Demo mode: when true, API calls are mocked so you can test without a backend\nexport const DEMO_MODE = true;\n\n// Cache duration for whitelist in milliseconds (10 minutes)\nexport const WHITELIST_CACHE_DURATION = 10 * 60 * 1000;\n\n// Request timeout in milliseconds\nexport const REQUEST_TIMEOUT = 30000; // 30 seconds\n\n// Storage keys\nexport const STORAGE_KEYS = {\n  WHITELIST_CACHE: 'whitelist_cache',\n  WHITELIST_CACHE_TIMESTAMP: 'whitelist_cache_timestamp',\n  CAPTURE_TOGGLE_PREFIX: 'host:', // followed by hostname:captureEnabled\n} as const;","import { STORAGE_KEYS } from './config';\nimport { WhitelistPattern } from './types/global';\nimport { logger } from './utils/logger';\n\nexport async function isWhitelisted(url: string): Promise<boolean> {\n  try {\n    const patterns = await getWhitelistPatterns();\n    const hostname = new URL(url).hostname;\n    \n    // Check if patterns match the URL\n    const isPatternMatch = patterns.some(pattern => matchesPattern(url, pattern.pattern));\n    \n    if (!isPatternMatch) {\n      logger.log(`URL not in whitelist patterns: ${url}`);\n      return false;\n    }\n    \n    // Check per-hostname toggle\n    const captureEnabled = await getHostCaptureToggle(hostname);\n    \n    logger.log(`Whitelist check for ${url}: pattern match=${isPatternMatch}, host toggle=${captureEnabled}`);\n    return captureEnabled;\n  } catch (error) {\n    logger.error('Error checking whitelist:', error);\n    return false;\n  }\n}\n\nasync function getWhitelistPatterns(): Promise<WhitelistPattern[]> {\n  // Hardcoded whitelist patterns\n  const patterns: WhitelistPattern[] = [\n    { pattern: 'https://www.midjourney.com/imagine*' },\n    { pattern: 'https://*.midjourney.com/*' },\n  ];\n  logger.log('Using hardcoded whitelist patterns');\n  return patterns;\n}\n\nfunction matchesPattern(url: string, pattern: string): boolean {\n  try {\n    // Convert wildcard pattern to regex\n    // Escape special regex characters except *\n    const escapedPattern = pattern.replace(/[.+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    // Replace * with .*\n    const regexPattern = escapedPattern.replace(/\\\\\\*/g, '.*');\n    // Anchor the pattern\n    const regex = new RegExp(`^${regexPattern}$`, 'i');\n    \n    return regex.test(url);\n  } catch (error) {\n    logger.error('Error matching pattern:', pattern, error);\n    return false;\n  }\n}\n\n// Remove caching functions as they are no longer needed with hardcoded whitelist\n// async function getCachedWhitelist(): Promise<WhitelistCache | null> {\n//   try {\n//     const result = await chrome.storage.session.get([\n//       STORAGE_KEYS.WHITELIST_CACHE,\n//       STORAGE_KEYS.WHITELIST_CACHE_TIMESTAMP,\n//     ]);\n// \n//     const patterns = result[STORAGE_KEYS.WHITELIST_CACHE];\n//     const timestamp = result[STORAGE_KEYS.WHITELIST_CACHE_TIMESTAMP];\n// \n//     if (patterns && timestamp) {\n//       return { patterns, timestamp };\n//     }\n// \n//     return null;\n//   } catch (error) {\n//     logger.error('Error reading cached whitelist:', error);\n//     return null;\n//   }\n// }\n// \n// async function cacheWhitelist(patterns: WhitelistPattern[]): Promise<void> {\n//   try {\n//     await chrome.storage.session.set({\n//       [STORAGE_KEYS.WHITELIST_CACHE]: patterns,\n//       [STORAGE_KEYS.WHITELIST_CACHE_TIMESTAMP]: Date.now(),\n//     });\n// \n//     logger.log('Whitelist patterns cached successfully');\n//   } catch (error) {\n//     logger.error('Error caching whitelist patterns:', error);\n//   }\n// }\n// \n// function isCacheValid(timestamp: number): boolean {\n//   return Date.now() - timestamp < WHITELIST_CACHE_DURATION;\n// }\n\nexport async function getHostCaptureToggle(hostname: string): Promise<boolean> {\n  try {\n    const key = `${STORAGE_KEYS.CAPTURE_TOGGLE_PREFIX}${hostname}:captureEnabled`;\n    const result = await chrome.storage.sync.get(key);\n    \n    // Default to true if not set\n    return result[key] !== false;\n  } catch (error) {\n    logger.error('Error getting host capture toggle:', error);\n    return true; // Default to enabled\n  }\n}\n\nexport async function setHostCaptureToggle(hostname: string, enabled: boolean): Promise<void> {\n  try {\n    const key = `${STORAGE_KEYS.CAPTURE_TOGGLE_PREFIX}${hostname}:captureEnabled`;\n    await chrome.storage.sync.set({ [key]: enabled });\n    \n    logger.log(`Set capture toggle for ${hostname}: ${enabled}`);\n  } catch (error) {\n    logger.error('Error setting host capture toggle:', error);\n    throw error;\n  }\n}"],"names":[],"mappings":";AAEO,MAAM,gBAAgB;AAatB,MAAM,eAAe;AAAA,EAC1B,iBAAiB;AAAA,EACjB,2BAA2B;AAAA,EAC3B,uBAAuB;AAAA;AACzB;ACfA,eAAsB,cAAc,KAA+B;AACjE,MAAI;AACF,UAAM,WAAW,MAAM,qBAAA;AACvB,UAAM,WAAW,IAAI,IAAI,GAAG,EAAE;AAG9B,UAAM,iBAAiB,SAAS,KAAK,CAAA,YAAW,eAAe,KAAK,QAAQ,OAAO,CAAC;AAEpF,QAAI,CAAC,gBAAgB;AACnB,aAAO,IAAI,kCAAkC,GAAG,EAAE;AAClD,aAAO;AAAA,IACT;AAGA,UAAM,iBAAiB,MAAM,qBAAqB,QAAQ;AAE1D,WAAO,IAAI,uBAAuB,GAAG,mBAAmB,cAAc,iBAAiB,cAAc,EAAE;AACvG,WAAO;AAAA,EACT,SAAS,OAAO;AACd,WAAO,MAAM,6BAA6B,KAAK;AAC/C,WAAO;AAAA,EACT;AACF;AAEA,eAAe,uBAAoD;AAEjE,QAAM,WAA+B;AAAA,IACnC,EAAE,SAAS,sCAAA;AAAA,IACX,EAAE,SAAS,6BAAA;AAAA,EAA6B;AAE1C,SAAO,IAAI,oCAAoC;AAC/C,SAAO;AACT;AAEA,SAAS,eAAe,KAAa,SAA0B;AAC7D,MAAI;AAGF,UAAM,iBAAiB,QAAQ,QAAQ,sBAAsB,MAAM;AAEnE,UAAM,eAAe,eAAe,QAAQ,SAAS,IAAI;AAEzD,UAAM,QAAQ,IAAI,OAAO,IAAI,YAAY,KAAK,GAAG;AAEjD,WAAO,MAAM,KAAK,GAAG;AAAA,EACvB,SAAS,OAAO;AACd,WAAO,MAAM,2BAA2B,SAAS,KAAK;AACtD,WAAO;AAAA,EACT;AACF;AAyCA,eAAsB,qBAAqB,UAAoC;AAC7E,MAAI;AACF,UAAM,MAAM,GAAG,aAAa,qBAAqB,GAAG,QAAQ;AAC5D,UAAM,SAAS,MAAM,OAAO,QAAQ,KAAK,IAAI,GAAG;AAGhD,WAAO,OAAO,GAAG,MAAM;AAAA,EACzB,SAAS,OAAO;AACd,WAAO,MAAM,sCAAsC,KAAK;AACxD,WAAO;AAAA,EACT;AACF;AAEA,eAAsB,qBAAqB,UAAkB,SAAiC;AAC5F,MAAI;AACF,UAAM,MAAM,GAAG,aAAa,qBAAqB,GAAG,QAAQ;AAC5D,UAAM,OAAO,QAAQ,KAAK,IAAI,EAAE,CAAC,GAAG,GAAG,SAAS;AAEhD,WAAO,IAAI,0BAA0B,QAAQ,KAAK,OAAO,EAAE;AAAA,EAC7D,SAAS,OAAO;AACd,WAAO,MAAM,sCAAsC,KAAK;AACxD,UAAM;AAAA,EACR;AACF;"}